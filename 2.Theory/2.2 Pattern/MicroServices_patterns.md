### Патерны микросервисной архитектуры

#### API Gateway
Он располагается на границе системы или сети микросервисов и служит единой точкой входа для всех клиентских запросов.  API Gateway направляет запросы к нужным микросервисам на основе заранее установленных правил, распределяя нагрузку между несколькими экземплярами сервисов для повышения надежности и масштабируемости. Это помогает избежать перегрузки отдельных сервисов.
API Gateway может выполнять трансляцию различных протоколов и форматов данных, например, преобразовывать HTTP-запросы в формат, который используется другими сервисами, такими как gRPC, для совместимости между микросервисами с разными протоколами.

#### Service Discovery
Представим себе несколько микросервисов, которые составляют одно более-менее сложное приложение. Разумеется, они будут каким-то образом взаимодействовать друг с другом. Обычно приложения на микросервисах работает через виртуализацию или в контейнерах, количество инстансов сервиса и их местоположение могут динамически изменяться. При этом нам необходимо знать имена этих инстансов и где они находятся, чтобы запросы могли поступать к целевому микросервису. Здесь и вступает в игру Service Discovery – механизм, который позволяет нам определить местоположение каждого инстанса, который действует как реестр адресов.

#### Circuit Breaker
Circuit Breaker это еще один полезный паттерн, который предназначен для обнаружения сбоев и управления ими. Он отслеживает взаимодействие между микросервисами и временно приостанавливает запросы к неисправному сервису, давая ему время на восстановление. Это помогает избежать дополнительной нагрузки на неисправный сервис и предотвращает эффект домино.

#### Event-Driven Architecture
Архитектура, управляемая событиями, она же EDA, она же Event-Driven Architecture. Это парадигма проектирования программного обеспечения, в которой компоненты системы взаимодействуют, генерируя события и реагируя на них. Такими событиями могут быть как действия пользователя, так и изменения состояния системы.
В EDA есть три типа компонентов:
1. События – сообщения, которые информируют о произошедших изменениях или состояниях в системе.
2. Поставщики событий – компоненты, которые генерируют события.
3. Подписчики на события – компоненты, которые реагируют на события и выполняют действия, связанные с изменениями.

#### Event Sourcing
В традиционных системах, при обновлении сущности, старые данные в БД перезаписываются, однако в микросервисной архитектуре такой подход приводит к несогласованности данных между несколькими сервисами, отсутствию возможности получить историю изменений данных и сложностям с отладкой.
Решить эту проблему становится возможным с паттерном Event Sourcing, где вместо того чтобы хранить только последнее состояние, мы сохраняем все изменения как последовательность неизменяемых событий.
Здесь каждое событие представляет собой изменение состояния (например, OrderCreated, OrderUpdated, OrderCancelled), текущее состояние определяется путем воспроизведения всех прошлых событий, что позволяет отслеживать полную историю и легко восстанавливать предыдущие состояния.

#### Strangler Pattern
Этот подход применяется при переходе от монолита к микросервисам и свое название он получил от того, как лиана медленно душит дерево, постепенно вытесняя его рост. Аналогично, Strangler Pattern предполагает постепенную замену частей монолитного приложения микросервисами.
В основном его используют, когда полное переписывание системы несет значительные риски, особенно когда система устаревшая, со сложной кодовой базой, рефакторинг которой осуществить невозможно. У него также есть несколько существенных особенностей. Вначале, мы осуществляем постепенную миграцию, заменяя отдельные функции или модули. Далее они сосуществуют с монолитом, обеспечивая бесперебойную работу системы и в конечном итоге, происходит «удушение», то есть окончательная замена монолита.

#### Database per Service
Важнейшая концепция микросервисной архитектуры, способствующая децентрализованному управлению данными за счёт назначения каждому сервису уникальной базы данных. База данных у каждого микросервиса может быть любого типа, которой наилучшим образом ему подходит.
Основной целью данного паттерна является обеспечение независимости и инкапсуляции данных, возможности масштабироваться независимо, а также устойчивость системы при сбоях, поскольку сбой в одной базе не повлияет на другие.
Однако, использование паттерна Database per Service также влечет за собой ряд проблем. Одной из ключевых проблем является обеспечение консистентности данных между микросервисами. Поскольку каждый микросервис имеет свою собственную базу данных, поддержание согласованности данных, особенно при их изменении в разных сервисах, может стать сложной задачей. Это особенно актуально при наличии транзакций, охватывающих несколько сервисов, что нарушает принципы ACID в традиционных реляционных СУБД.
Для решения этой проблемы часто используют различные подходы, например событийную модель Event-Driven Architecture, которую я уже рассмотрела выше.
Кроме того, для обработки распределённых транзакций, когда необходимо изменить данные в нескольких микросервисах, можно использовать паттерн Saga. Он представляет собой серию локальных транзакций, выполняемых разными сервисами, каждая из которых имеет свою логику отката, если одна из транзакций не удалась.

#### CQRS (Command Query Responsibility Segregation)
CQRS это паттерн, используемый в разработке для разделения задач обработки команд и выполнения запросов к данным. Этот паттерн разделяет обработку команд, которые изменяют данные, и запросов, которые извлекают данные в программных системах. Такое разделение даёт большую гибкость и масштабируемость при управлении сложными операциями. В системе, использующей паттерн CQRS, команды отвечают за изменение состояния системы, а запросы — за извлечение данных из неё.

