### Антипатерны

#### Общее ядро (Shared Kernel) 
**Общее ядро (Shared Kernel)** в предметно-ориентированном проектировании (DDD) - это ограниченный контекст, который содержит код и данные, общие для нескольких других ограниченных контекстов в рамках одного домена. Он служит центральным хранилищем для элементов единого языка, логики предметной области и структур данных, которые используются совместно. 
**Пример:**
Предположим, у нас есть домен "Управление заказами" с двумя ограниченными контекстами: "Заказы клиентов" и "Склад". В обоих контекстах используется информация о продуктах, такая как название, описание, цена и т.д. Вместо того, чтобы дублировать эту информацию и логику работы с ней в каждом контексте, можно создать общее ядро "Каталог продуктов".

**Преимущества использования общего ядра:**
- **Сокращение дублирования кода:** Изменение логики продукта в одном месте влияет на все контексты, использующие общее ядро.
- **Улучшение согласованности:** Обеспечивается единый взгляд на информацию о продуктах во всех контекстах. 
- **Улучшение понимания предметной области:** Единый язык и общие понятия упрощают коммуникацию между разработчиками и экспертами.  
- **Более простая разработка новых контекстов:** Можно повторно использовать код и информацию из общего ядра при создании новых контекстов. 

**Важно:**
- Общее ядро должно быть небольшим и содержать только наиболее часто используемые элементы.
- Слишком большое общее ядро может привести к сложностям в поддержке и увеличению связности между контекстами, что противоречит принципам DDD.
- Изменения в общем ядре должны тщательно планироваться и тестироваться, чтобы не нарушить работу других контекстов. 

#### Copy and Paste
Антипаттерн **"Copy and Paste"** (копирование-вставка) означает использование копирования и вставки кода вместо создания переиспользуемых решений. Это приводит к дублированию кода, усложняет поддержку и внесение изменений, а также может приводить к ошибкам. 

#### MVC (Model-View-Controller)
Антипаттерн **MVC (Model-View-Controller)** возникает, когда шаблон проектирования MVC используется неправильно, что приводит к проблемам с кодом, его обслуживанием и пониманием. Это может проявляться в смешивании ответственности между компонентами, излишней сложности или неэффективности.

#### Controller
Антипаттерн **"Controller"** в контексте разработки программного обеспечения относится к классам-контроллерам, которые выполняют слишком много функций, часто просто перенаправляя вызовы в другие классы, вместо реализации собственной логики. Это может приводить к размыванию ответственности, усложнению поддержки и тестирования, а также к нарушению принципа единственной ответственности. В сущности, **"Controller"** как антипаттерн возникает, когда класс-контроллер становится слишком большим и сложным, перегруженным обязанностями, которые не должны быть его ответственностью. Вместо того, чтобы координировать работу других объектов и предоставлять интерфейс для взаимодействия с системой, он начинает выполнять логику, которая должна находиться в других классах, или даже манипулировать данными напрямую. 

#### Монолитный (Monolithic)
**Монолитный антипаттерн**, или монолитный ад, относится к ситуации, когда приложение строится как единый неразделимый блок, что приводит к проблемам с масштабируемостью, сложностью поддержки и развертывания. Это антипаттерн, поскольку он усложняет разработку и обслуживание по мере роста приложения.

#### Спагетти-код (Spaghetti code)
**Спагетти-код** - это антипаттерн программирования, характеризующийся отсутствием четкой структуры, избыточными переходами, сложными условиями и трудностями в понимании и поддержке. По сути, это плохо организованный, запутанный код, напоминающий клубок спагетти. 


#### Большой комок грязи (Big ball of mud)
**Большой комок грязи (Big ball of mud)** — программная система с нераспознаваемой архитектурой. Хотя это нежелательно с точки зрения программной инженерии, такие системы распространены на практике из-за давления бизнеса, текучки кадров среди разработчиков и энтропии кода. Они представляют собой тип анти-шаблона дизайна. 
`Большой комок грязи — это беспорядочно структурированные, растянутые, неряшливые, словно перемотанные на скорую руку изолентой и проволокой, джунгли спагетти-кода. Эти системы показывают безошибочные признаки нерегулируемого роста и постоянных доделок. Информация делится беспорядочно между отдаленными элементами системы, часто до такой степени, что почти вся важная информация становится глобальной или дублируется. Общая структура системы, возможно, никогда не была четко определена. Если и была, то стала размыта до неузнаваемости. Программисты хоть немного понимающие архитектуру, обходят это болото стороной. И только те, кого она волнует мало и, возможно, те, кому нравится латать дыры в системе каждый день, довольны работой над такими системами.
Brian Foote and Joseph Yoder, Big Ball of Mud. Fourth Conference on Patterns Languages of Programs (PLoP '97/EuroPLoP '97) Monticello, Illinois, September 1997`
 
#### Hard code
**Антипаттерн "hard code" (или жесткое кодирование)** – это практика, когда данные, которые должны быть внешними по отношению к коду (например, пути к файлам, настройки, параметры, ключи API), непосредственно вшиваются в исходный код. Это приводит к проблемам с поддержкой, переносимостью и безопасностью приложения

#### Overengineering
**Overengineering (перепроектирование, чрезмерное усложнение)** - это антипаттерн в разработке программного обеспечения, когда система создается с избыточной сложностью, которая не соответствует ее функциональным требованиям. Проще говоря, разработчики создают слишком сложную систему для решения простой задачи

#### Изобретение колеса (Reinventing the wheel)
Антипаттерн **Изобретение колеса (Reinventing the wheel)** в программировании означает, что разработчик тратит время и ресурсы на создание решения для задачи, для которой уже существует готовое, проверенное и часто более эффективное решение, доступное в библиотеках, фреймворках или других компонентах. Вместо того, чтобы использовать существующие наработки, разработчик пытается создать что-то "свое", часто с худшими результатами. 

#### Мертвый код (Dead code)
**Мертвый код (Dead code)**, также известный как неиспользуемый или бесполезный код, это фрагменты кода, которые не оказывают влияния на работу программы и могут быть безопасно удалены без изменения ее функциональности. Он может включать в себя переменные, которые не используются, функции, которые не вызываются, или целые блоки кода, которые никогда не выполняются. Хотя мертвый код может быть не очевиден, он может снижать производительность программы и затруднять ее поддержку. 

#### Божественный объект (God Object)
**Божественный объект (God Object)** — антипаттерн объектно-ориентированного программирования, описывающий объект, который хранит в себе «слишком много» или делает «слишком много». 

Основная идея модульного программирования состоит в том, что большая задача делится на меньшие относительно независимые подзадачи (принцип «разделяй и властвуй»). В развитии модульного программирования — объектно-ориентированном программировании — этот принцип выражается в создании множества объектов, каждый из которых решает только свою собственную задачу.

Подход «божественного объекта» противоположен этому принципу: основная часть функциональности программы кодируется в одном объекте. Так как этот объект хранит большое количество данных и имеет много методов, его роль в программе становится «божественной» (всеобъемлющей).

Вместо того, чтобы общаться друг с другом непосредственно, другие объекты полагаются на божественный объект. Так как на божественный объект ссылается так много кода, его обслуживание (внесение изменений) становится сложным: велик риск сломать существующую функциональность.

Божественный объект — это объектно-ориентированный аналог отказа от использования подпрограмм в процедурном программировании или использования слишком большого количества глобальных переменных для хранения информации о состоянии программы.

Хотя божественные объекты считаются плохой практикой программирования, поскольку вредят поддерживаемости кода, они могут быть полезны для работы при ограниченных ресурсах (в микроконтроллерах или мобильных телефонах), где производительность важнее, чем поддерживаемость кода. 

#### Золотой молоток (Golden Hammer)
**Золотой молоток (Golden Hammer)** — уверенность в полной универсальности какого-либо решения и применение этого решения (например, одного из паттернов проектирования в программировании) к любым задачам. Склонность к использованию «золотого молотка» не зависит от опыта специалиста. 

#### Лодочный якорь (Boat Anchor)
Антипаттерн **"Лодочный якорь" (Boat Anchor)** означает наличие в коде неиспользуемых фрагментов, которые остались после оптимизации или рефакторинга, либо были оставлены "на всякий случай". Эти фрагменты не приносят пользы, но усложняют код, затрудняют понимание и поддержку, а также могут увеличивать время сборки и даже привести к ошибкам в продакшене. 

#### Лавина сервисов (Service Avalanche)
Антипаттерн **"Лавина сервисов" (Service Avalanche)** возникает, когда один сервис вызывает большое количество других сервисов для выполнения своей работы, что приводит к каскадным зависимостям и усложнению системы. Это может проявляться в виде чрезмерного количества вызовов между сервисами, что затрудняет понимание, поддержку и масштабирование системы.

#### Ад зависимостей (Dependency hell)
**Ад зависимостей (Dependency hell)** — антипаттерн управления конфигурацией, разрастание графа взаимных зависимостей программных продуктов и библиотек, приводящее к сложности установки новых и удаления старых продуктов. В сложных случаях различные установленные программные продукты требуют наличия разных версий одной и той же библиотеки. В наиболее сложных случаях один продукт может косвенно потребовать сразу две версии одной и той же библиотеки. Проблемы с зависимостями возникают у общих пакетов/библиотек, у которых некоторые другие пакеты имеют зависимости от несовместимых и различных версий общих пакетов. Если установлена одна версия общего пакета/библиотеки, для решения этой проблемы автоматизатору тестирования/программисту/администратору понадобится получить новые или старые версии зависимых пакетов. Это, в свою очередь, может нарушить работу других зависимых пакетов и добавить проблем в другой набор пакетов, таким образом образуя настоящий ад. 

#### Состояние гонки (race condition)
Состояние гонки (race condition) - это антипаттерн, возникающий в многопоточных или многопроцессорных системах, когда несколько потоков или процессов одновременно обращаются к общим ресурсам, и порядок их выполнения влияет на результат, что может приводить к непредсказуемому и ошибочному поведению программы. Состояние гонки — «плавающая» ошибка (гейзенбаг), проявляющаяся в случайные моменты времени и «пропадающая» при попытке её локализовать. 

#### Null hell
Антипаттерн **"Null Hell"** возникает, когда в коде широко используются условные операторы для проверки на null перед каждым обращением к объекту или свойству. Это приводит к увеличению объема кода, снижению его читаемости и повышению вероятности ошибок.

#### Trait
Антипаттерн **Trait** относится к случаям, когда использование трейтов в объектно-ориентированном программировании приводит к проблемам, несмотря на то, что трейты часто используются для повторного использования кода. В контексте трейтов, антипаттерн возникает, когда их применение усложняет код, делает его менее читаемым или приводит к неожиданному поведению. 

В программировании trait (в русском языке часто используется термин "типаж" или "трейт") — это механизм повторного использования кода, который позволяет объединять функциональность в независимые блоки, которые могут быть "включены" в различные типы (классы, структуры и т.д.). Это помогает избежать дублирования кода и упрощает организацию объектно-ориентированных программ, особенно при наследовании. 

#### Синглтон (Singleton)
**Синглтон (Singleton)** – это порождающий шаблон проектирования, который гарантирует наличие только одного экземпляра класса и предоставляет глобальную точку доступа к этому экземпляру. В некоторых случаях, и особенно при неправильном применении, синлтон может считаться антипаттерном.

#### Анемичная модель (Anemic Model)
**Анемичная модель (Anemic Model)** — это антипаттерн в объектно-ориентированном проектировании, при котором объекты предметной области (domain objects) содержат только данные (свойства, поля) и не имеют связанного с ними поведения (методов). Вся логика и бизнес-правила, относящиеся к этим объектам, выносятся в отдельные сервисы или слои, что противоречит принципам инкапсуляции и объектно-ориентированного подхода. 

**Суть антипаттерна:**
В анемичной модели объекты предметной области превращаются в простые контейнеры для данных, а логика их обработки переносится в другие части системы, например, в сервисы, контроллеры или отдельные классы. Это приводит к размыванию ответственности, ухудшению поддержки и понимания кода, а также к дублированию логики в разных частях приложения. 
**Признаки анемичной модели:**
- Объекты предметной области содержат только геттеры и сеттеры для доступа к данным.
- Вся логика, связанная с этими объектами, находится вне их.
- Код, работающий с данными, разбросан по разным слоям приложения. 

**Пример:**
Предположим, у нас есть класс User с данными (имя, фамилия, email) и методы для изменения этих данных (например, setName, setEmail). В анемичной модели эти методы, по сути, являются простыми сеттерами. Логика, например, проверка уникальности email при регистрации, выносится в отдельный сервис UserService. В богатой модели (Rich Model) эта проверка была бы частью самого объекта User, например, в методе changeEmail, который бы проверял уникальность и при необходимости выбрасывал исключение. 

#### Active Record
**Active Record** – это шаблон проектирования, который часто подвергается критике и считается антипаттерном в некоторых контекстах, особенно в больших проектах. Несмотря на его широкую распространенность в ORM (Object-Relational Mapping), его обвиняют в нарушении принципов разделения ответственности и слабой поддержке ограничений предметной области. 

**Почему Active Record считается антипаттерном:**
- **Нарушение принципа единственной ответственности:** В Active Record модель одновременно отвечает и за бизнес-логику, и за доступ к данным, что приводит к увеличению объема кода в одном классе.
- **Сложность поддержки и расширения:** Из-за тесной связи с базой данных, изменения в схеме базы данных могут потребовать значительных изменений в коде, что усложняет поддержку и расширение системы.
- **Трудности с тестированием:** Тестирование бизнес-логики, связанной с Active Record, может быть затруднено из-за необходимости взаимодействия с базой данных.
- **Слабая поддержка ограничений предметной области:** В Active Record сложно обеспечить соблюдение сложных бизнес-правил и ограничений, так как логика, связанная с ними, часто размазана по разным частям кода. 



