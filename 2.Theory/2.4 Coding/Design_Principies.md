### Принципы разработки

#### SOLID

- S (Single Responsibility Principle) – принцип единственной ответственности;

  Каждый класс или модуль должен иметь только одну причину для изменения. Это означает, что класс должен выполнять только одну конкретную функцию или задачу, что облегчает его понимание, тестирование и поддержку.


| Название                                         | Описание                                                                                                                                                                                                  |
| -------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Упрощенная сопровождаемость    | Если класс выполняет одну функцию, изменения в ней не затрагивают другие части системы                                                   |
| Уменьшение сложности                  | Классы с единой ответственностью проще и понятнее, что снижает сложность кода и облегчает его анализ                         |
| Повышение гибкости                      | Изменения класса с единой ответственностью предсказуемы и не влияют на другие части системы                                        |
| Повторное использование            | Классы с четко определенной ответственностью подходят для повторного использования в других системах                     |
| Легкость в тестировании             | Когда класс отвечает только за одну функциональность, его тестирование может быть более изолированным и понятным |
| Читаемость и воспринимаемость | Классы с узкой ответственностью более понятны, так как они представляют собой логически независимые модули            |

- O (Open/Сlosed Principle) – принцип открытости‑закрытости;

  Данный принцип гласит, что программные сущности, такие как классы, модули и функции, должны быть открыты для расширения и закрыты для модификации. Другими словами, когда требуется изменить поведение системы, это должно происходить без изменения кода существующих компонентов, путем добавления новых компонентов или расширения существующих.


| Название                                 | Описание                                                                                                                                                                                                     |
| ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Сопровождаемость                 | Добавление функциональности без изменения старого кода снижает риск ошибок и способствует минимальным изменениям |
| Расширяемость                       | Принцип позволяет добавлять новые функции, не затрагивая существующий функционал, что упрощает разработку                |
| Устойчивость к изменениям | Если при изменениях приходится править старый код, растёт риск ошибок. Принцип помогает избежать этого                        |
| Повторное использование    | Существующие компоненты можно повторно использовать без изменений, что способствует уменьшению дублирования кода |

- L (Liskov Substitution Principle) – принцип подстановки Барбары Лисков;

  Данный принцип акцентирует важность того, чтобы объекты подклассов могут быть использованы в коде программы вместо объектов их базовых классов, не вызывая непредвиденных проблем или нарушений функциональности. Объекты подклассов должны быть подставляемы вместо объектов базовых классов без нарушения корректности выполнения программы.


| Название                                                       | Описание                                                                                                                                                                                 |
| ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Поддержание совместимости                      | Принцип подстановки делает код гибким: новые подклассы не ломают существующую логику                                    |
| Упрощение использования наследования | Принцип подстановки позволяет использовать подклассы вместо базового класса без изменения кода               |
| Избежание непредвиденных ошибок           | Если соблюдён принцип подстановки, замена базового класса на подкласс не вызывает ошибок                             |
| Создание более гибких архитектур          | Принцип подстановки позволяет добавлять подклассы без переписывания старого кода                                         |
| Обеспечение предсказуемости                  | Принцип подстановки помогает предсказать поведение кода с разными объектами и сделать систему надежнее |

- I (Interface Segregation Principle) – принцип разделения интерфейса;

  Данный принцип уделяет внимание разделению больших, общих интерфейсов на более мелкие и специфичные, чтобы клиенты могли зависеть только от тех методов, которые им действительно нужны.


| Название                                                            | Описание                                                                                                                                                                                                                                                                                                                            |
| --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Снижение зависимостей                                   | Разбивая общие интерфейсы на более мелкие, можно уменьшить количество методов, от которых зависят клиенты. Это позволяет уменьшить связность кода и упростить его сопровождение       |
| Повышение гибкости                                         | Принцип разделения интерфейсов позволяет сделать архитектуру гибкой — клиенты зависят только от нужных им частей, что позволяет менять или добавлять функции без влияния на других |
| Улучшение читаемости и воспринимаемости | Код становится более понятным и читаемым, так как он описывает только те взаимодействия, которые действительно имеют значение для клиента                                                                              |
| Повторное использование                               | Малые и узкоспециализированные интерфейсы облегчают повторное использование компонентов в системе                                                                                                                                                   |

- D (Dependency Inversion Principle) – принцип инверсии зависимостей.

  Данный принцип заключается в том, что зависимости между модулями и компонентами программы должны быть организованы таким образом, чтобы более низкоуровневые компоненты зависели от абстракций, а не наоборот.


| Название                                     | Описание                                                                                                                                                                                                                                                                                                                                                                                                  |
| ---------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Снижение связности                  | Высокоуровневые компоненты (абстракции) не зависят напрямую от низкоуровневых деталей, что позволяет легче менять детали без воздействия на абстракции                                                                                                                          |
| Гибкость и масштабируемость | Принцип позволяет создавать более гибкие и масштабируемые архитектуры, так как изменение деталей в низкоуровневых компонентах не должно приводить к изменению высокоуровневых компонентов                                                      |
| Обратимость зависимостей      | Инвертирование зависимостей обеспечивает возможность повторного использования компонентов и модулей в разных контекстах, так как высокоуровневые модули могут зависеть от одних и тех же абстракций в разных сценариях |
| Тестирование                             | Принцип позволяет легче тестировать компоненты, так как высокоуровневые компоненты могут быть заменены на имитации для тестирования низкоуровневых деталей                                                                                                                |
| Расширяемость                           | Принцип инверсии зависимостей позволяет добавлять новые детали или компоненты без изменения высокоуровневых абстракций                                                                                                                                                                                  |

#### DRY — Don't repeat yourself ("Не повторяйся")

«Каждая единица знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы» («Every piece of knowledge must have a single, unambiguous, authoritative representation within a system»)

#### KISS — Keep it simple, stupid («Делай проще, тупица»)

Принцип KISS подразумевает, что программное решение должно быть максимально простым и понятным.

#### YAGNI — You Ain't Gonna Need It ("Вам это не понадобится")

Это принцип разработки, согласно которому не стоит реализовывать функциональность, которая возможно пригодится в будущем, но не требуется сейчас. Он помогает избегать лишнего кода и сосредоточиться на актуальных задачах

#### APO — Avoid Premature Optimization ("Избегайте преждевременной оптимизации")

Это принцип разработки, согласно которому не стоит оптимизировать код до тех пор, пока в этом действительно не возникнет необходимость. Ранняя оптимизация усложняет систему и может тратить ресурсы на нерешающие задачи.

#### BDUF — Big Design Up Front ("Глобальное проектирование прежде всего")

Это принцип разработки, согласно которому вся архитектура и детали системы тщательно продумываются до начала разработки. Принцип предупреждает, что чрезмерное планирование на ранних этапах может привести к ненужной сложности и плохой адаптации к изменениям.

#### Бритва О́ккама ("Не следует множить сущее без необходимости")

Это принцип разработки, который гласит: «Не следует множить сущности без необходимости» (или «Среди конкурирующих гипотез следует выбирать самую простую, если нет веских доказательств обратного»).
Проще — лучше: выбирай самое простое решение, если нет веских причин делать сложнее. Не создавай лишних сущностей, классов, абстракций, переменных, уровней логики, если без них можно обойтись.

#### RUG - Repeat Until Good - повторяй код пока это разумно

На ранних этапах разработки важнее просто реализовать логику, исходя из текущих требований, чем пытаться сразу создать «идеальную» абстракцию. В этот момент задача — как можно быстрее получить рабочее решение, которое отражает текущие знания о системе. Но со временем, когда одна и та же логика начинает встречаться всё чаще, становится очевидно, что её удобнее и правильнее выделить в отдельную, чётко оформленную абстракцию, чтобы избежать дублирования и упростить дальнейшую поддержку.

#### Читаемость важнее универсальности

Код пишется один раз, но читается десятки и сотни раз. Особенно это актуально для тестов: их читают новички, аналитики, иногда даже менеджеры. Лучше, чтобы тест сразу объяснял, что он делает, чем выглядел как мини-фреймворк, который сначала нужно понять.

#### Оптимизируйте только то, что реально повторяется

Если один и тот же блок кода встречается в десятках мест — да, стоит вынести его в отдельную функцию или класс. Но если повторение встречается всего один-два раза, иногда проще оставить его «как есть». Оптимизировать стоит только то, что действительно экономит усилия, а не ради самого факта «обобщения».

#### Явное лучше, чем неявное (Explicit is better than implicit)

Когда код очевиден и читается буквально как инструкция, его проще понять, поддерживать и изменять. Излишние абстракции часто делают код «умнее, чем он есть на самом деле»: приходится разбираться в скрытых связях, динамических вызовах и «магии». Лучше написать простой и прямой вызов, чем заставлять коллег догадываться, как оно всё работает «под капотом».

#### SOSAL
- **Socially-Conscious Code (Социально-осознанный код)**

Принцип Socially-Conscious Code гласит о самом главном концепте работы в команде: кооперации. Для создания дружелюбной кодовой базы, каждому последователю идеологии SOSAL необходимо подробно изучить язык, но необычным образом. Самые главные части языка при работе в команде это стиль кода, чистота кода и идиоматические подходы: изучите стиль кода, распространённые методы решения проблем в языке. Это позволит остальным программистам команды быстрее влиться в решение рабочих задач.

- **Open by Default (Открытость по умолчанию)**

Принцип Open by Default призывает к открытости кода, при отсутствии причин для обратного. Также этот принцип рекомендует комментировать код так, как будто его читают те, кто только учится программировать. Понять когда нужно комментировать или нет в этом случае очень просто (при условии что вы достаточно хороший программист): если решение проблемы не возникает машинально, или возникает через достаточно длительный срок, то рекомендуется оставить комментарий.

- **Simple Scalability (Сбалансированная масштабируемость)**

Принцип Simple Scalability рекомендует писать код, который легко масштабируется. Но стоит сказать, что реализация преждевременных оптимизаций – зло. Простота не есть примитивность, также как сложность не есть крутость.

- **Agile Adaptivity (Адаптивность выше догм)**

Принцип Agile Adaptivity говорит о том, что код должен быть готов к изменениям, даже если они кажутся маловероятными. Обычно, при разработке сложных консольных утилит, я беру готовую библиотеку для обработки флагов и настроек, так как конфигурация на стадии разработки может очень сильно меняться. Стоит соблюдать границу между YAGNI (You Aren't Gonna Need It) и возможностью «эволюции» кодовой базы.

- **Learning-Driven Logic (Логика, основанная на обучении)**

Принцип Learning-Driven Logic призывает писать свой код так, чтобы в процессе написания он учил тебя и других. Рефакторинг – не наказание, а повод применить свои навыки. Эксперименты поощряются в том случае, если вы оставляете после себя «чистый след».

#### GOVNO

- **Governance (Управление)** – управление, которое относится к системам и процессам, созданным для обеспечения того, чтобы все члены команды работали над достижением одних и тех же целей и несли ответственность за свои действия. В GOVNO управление достигается за счет сочетания четких ролей и обязанностей, регулярных синков и ревью, а также прозрачного обмена информацией.
- **Objectives (Цели)** – это задачи, которые относятся к конкретным целям, над достижением которых работает каждый проект. В рамках GOVNO цели устанавливаются в начале каждого проекта и должны быть четкими, измеримыми и согласовываться с общими целями организации. Такой подход позволяет членам команды отслеживать их прогресс и вносить необходимые коррективы, чтобы убедиться, что они находятся на пути к достижению своих целей.
- **Visibility (Открытость)** – прозрачность и открытость информации на протяжении всего жизненного цикла проекта. Видимость достигается за счет регулярных обновлений, открытого общения и использования инструментов и технологий для совместной работы. Ориентация на наглядность помогает укрепить доверие и сотрудничество внутри команды, поскольку члены команды могут видеть прогресс своих коллег и понимать, как их работа вписывается в более широкие цели проекта. Кроме того, акцент на наглядности помогает выявить потенциальные проблемы и препятствия на раннем этапе, позволяя команде корректировать свой подход и корректировать курс по мере необходимости.
- **Networks (Сети)** – нетворкинг или связи поощряются за счет использования открытых пространств для совместной работы, регулярных кросс-функциональных встреч и обмена знаниями и опытом между командами. Такой подход позволяет членам команды учиться друг у друга и делиться своими уникальными взглядами, что приводит к более творческим и эффективным решениям проблем.
- **Outcomes (Результаты)** – ориентация на достижение высококачественных результатов для каждого проекта. Это означает, что успех проекта измеряется не количеством выполненной работы или задач, а качеством достигнутых результатов. Такое смещение фокуса позволяет командам расставить приоритеты в наиболее важных аспектах проекта и сосредоточиться на достижении наилучших возможных результатов. Сосредоточив внимание на результатах, команды могут лучше адаптироваться к изменяющимся условиям и легче использовать обратную связь и обучение в своей работе.
