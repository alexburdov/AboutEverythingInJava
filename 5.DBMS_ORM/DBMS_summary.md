### DBMS краткие заметки

#### Индексы

**B-tree (по умолчанию)**

- Лучший выбор для: =, <, >, BETWEEN, ORDER BY.
- Поддерживает сортировку.
- Используется в 90% случаев.Используется в 90% случаев.

```sql
CREATE INDEX idx_users_name ON users(name);
```

**Hash**

- Только для точного сравнения =.
- Не поддерживает диапазоны, сортировку, LIKE.
- Редко используется, но может быть быстрее B-tree на =.

```sql
CREATE INDEX idx_users_email_hash ON users USING hash(email);
```

**GIN (Generalized Inverted Index)**

- Для массивов, jsonb, full-text search.
- Отличен при поиске по вложенным структурам или множеству значений.

```sql
CREATE INDEX idx_data_tags ON posts USING gin(tags);
```

**GiST (Generalized Search Tree)**

- Для геоданных (PostGIS), поиска по диапазонам, tsvector.
- Более универсален, но медленнее в некоторых кейсах, чем GIN.

```sql
CREATE INDEX idx_events_location ON events USING gist(location);
```

**BRIN (Block Range Index)**

- Для огромных таблиц, где данные физически упорядочены.
- Занимает очень мало места.
- Не всегда эффективен — зависит от корреляции данных.

```sql
CREATE INDEX idx_logs_timestamp ON logs USING brin(timestamp);
```

#### Типичные проблемы с типами данных

- **TIMESTAMP (WITHOUT TIME ZONE)** - используется по default. Нет смысла использовать TIMESTAMP (WITHOUT TIME ZONE), так как это может привести к ошибкам при вычислениях из-за отсутствия контекста часового пояса и перехода на летнее/зимнее время. Правильный тип для хранения временных меток как конкретных моментов времени — TIMESTAMP WITH TIME ZONE.
- **TIME WITH TIME ZONE** - включён в PostgreSQL только ради соответствия SQL-стандарту. Поскольку он также занимает 8 байт, нет никакой причины его использовать — вместо него рекомендуется использовать TIMESTAMPTZ.
- **CURRENT_TIME** - Если вы решите использовать CURRENT_TIME, вы столкнётесь с теми же проблемами, что и при работе с TIMETZ. Выбор нужно опираться на


| Функция                 | Тип возвращаемого значения | Пример результата |
| ------------------------------ | -------------------------------------------------- | --------------------------------- |
| CURRENT_TIMESTAMP или now() | timestamp with time zone                           | 2023-11-20 21:03:34.349275+00     |
| CURRENT_DATE                   | date                                               | 2023-11-20                        |
| CURRENT_TIME                   | time with time zone                                | 21:03:34.349275+00                |
| LOCALTIMESTAMP                 | timestamp without time zone                        | 2023-11-20 21:03:34.349275        |
| LOCALTIME                      | time without time zone                             | 21:03:34.349275                   |

- **CHAR(n)** - Это текстовый тип фиксированной длины с заполнением пробелами. Его длина всегда равна n, как указано в определении. Если строка короче n символов, оставшееся пространство дополняется пробелами. Но будьте осторожны: при использовании LIKE и регулярных выражений (regex) пробелы не игнорируются! Что ещё хуже — внутри PostgreSQL тип CHAR(n) не хранится как поле фиксированной длины. Поскольку символы могут занимать более одного байта (в зависимости от кодировки), сохраненная строка на диске представлена в виде значения переменной длины. В результате вы можете тратить место на диске впустую, сохраняя ненужные пробелы, так как они сохраняются явно. Наконец, индексы, созданные по колонкам с типом CHAR(n), могут не работать в запросах, где используется значение типа TEXT, переданное из клиента PostgreSQL.
- **VARCHAR(n)** При попытке вставить более длинную строку произойдёт ошибка: ERROR:  value too long for type character varying(5). Итог: не используйте VARCHAR(n), он может только создать проблемы, не давая при этом никаких преимуществ. Используйте TEXT.
- **Тип BPCHAR** - Игнорирует при сравнение пробелы в конце строки.
- **MONEY** - не хранит информацию о валюте и страдает от ограниченной и ошибочной реализации. Его следует избегать и вместо него использовать NUMERIC или другие числовые типы, способные точно хранить значения. При необходимости валюту лучше сохранять в отдельной колонке.
- **Тип данных SERIAL  и BIGSERIAL** - фактически устарели и были вытеснены identity-колонками, которые обладают более предсказуемым поведением в плане владения последовательностями, их использования и понятности, к какой таблице они относятся.
- **XML** — крайне неудачный выбор для хранения документов, если только вы не собираетесь просто копировать неизменяемые XML-данные в базу. Если вы планируете выполнять запросы или модифицировать данные, используйте JSON(B).

#### Fillfactor

**Fillfactor** — это параметр, который говорит PostgreSQL: оставь немного места на каждой странице, пожалуйста, заранее. То есть если ты ставишь fillfactor = 80, то Postgres будет заполнять каждую страницу на 80%, оставляя 20% под будущие апдейты. По дефолту fillfactor = 100. А значит, если часто происходят UPDATE или HOT UPDATE, можно влететь в проблему — Postgres не сможет обновить строку “на месте” и вынужден будет делать tuple forwarding (и создавать новый tuple), что ведёт к фрагментации и росту таблицы.

```sql
CREATE TABLE users (
  id serial PRIMARY KEY,
  name text,
  email text
) WITH (fillfactor = 80);

ALTER TABLE users SET (fillfactor = 70);

CREATE INDEX idx_email ON users(email) WITH (fillfactor = 90);
```

**Когда стоит занижать fillfactor вручную**

*Не трогай fillfactor, если не уверен в профиле нагрузки. По дефолту он справедлив — 100%.*

- Частые UPDATE’ы фиксированных строк
- Типичный кейс — статус заказа. Меняется несколько байт, но меняется часто.
- **Frequent UPSERT паттерны** Особенно если UPSERT делают UPDATE чаще, чем INSERT.
- **Суровые OLTP-нагрузки** Где каждый микросервис по 100 раз в секунду пишет в те же записи (а ты ещё решил shard'ить вручную, да?).
- **Частые UPDATE по jsonb / text** Где строка может даже слегка вырасти.

#### Стратегии управления транзакциями

В контексте баз данных, "ACID" и "BASE" - это два различных подхода к управлению транзакциями, определяющие, как данные обрабатываются и какие гарантии надежности и согласованности предоставляются. ACID (Atomicity, Consistency, Isolation, Durability) - это классический подход, обеспечивающий строгую согласованность данных, в то время как BASE (Basically Available, Soft state, Eventually consistent) - более гибкий подход, нацеленный на высокую доступность и отказоустойчивость, жертвуя некоторой степенью согласованности

#### ACID

Это традиционный подход, часто используемый в реляционных базах данных, таких как PostgreSQL. Он обеспечивает надежность и предсказуемость работы, но может быть более медленным и менее масштабируемым, особенно в распределенных системах.

**ACID** - Atomicity, Consistency, Isolation, Durability

- **Atomicity(Атомарность)** Гарантирует, что транзакция либо выполняется полностью, либо не выполняется вообще. Никакие частичные изменения не сохраняются.
- **Consistency(Согласованность)** Обеспечивает, что любая транзакция переводит базу данных из одного согласованного состояния в другое, то есть не нарушает предустановленные правила и ограничения.
- **Isolation(Изолированность)** Обеспечивает, что параллельно выполняющиеся транзакции не влияют друг на друга, создавая иллюзию последовательного выполнения.
- **Durability(Долговечность)** Гарантирует, что после подтверждения транзакции изменения сохраняются и не будут потеряны даже в случае сбоя системы.

#### BASE

Это подход, ориентированный на доступность и масштабируемость, часто используемый в NoSQL базах данных. Он позволяет достичь высокой производительности и отказоустойчивости за счет упрощения требований к согласованности данных, что делает его подходящим для распределенных систем, где требуется высокая доступность.

**BASE** - Basically Available, Soft state, Eventually consistent

- **Basically Available(Базовая доступность)** Гарантирует, что база данных будет доступна в любом случае.
- **Soft state(Мягкий состав)** Позволяет хранить несогласованные изменения, но не гарантирует их надежности.
- **Eventually consistent(Возможно согласованная)** Гарантирует, что данные будут согласованы в конечном состоянии, но не гарантирует их надежности.