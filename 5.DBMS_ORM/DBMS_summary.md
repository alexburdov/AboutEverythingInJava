### DBMS краткие заметки

#### Индексы

**B-tree (по умолчанию)**
- Лучший выбор для: =, <, >, BETWEEN, ORDER BY.
- Поддерживает сортировку.
- Используется в 90% случаев.Используется в 90% случаев.

B-дерево — самая распространённая индексная структура. Как и SSTable, оно хранит пары «ключ — значение» в отсортированном виде, что позволяет быстро искать ключи и выполнять диапазонные запросы.

Но в отличие от SSTable, B-дерево делит данные на страницы фиксированного размера (обычно 4 КБ), которые читаются и записываются по одной. Каждая страница хранит ключи и ссылки на дочерние страницы, формируя дерево. Поиск всегда начинается с корневой страницы и проходит через страницы, отвечающие за диапазоны ключей, пока не найдётся нужное значение.

![img.png](img/sum_02.png)

**Разница между индексами (user_id, status) и (user_id) INCLUDE (status)**
_Составной индекс (user_id, status)_
1. **Структура**: Оба поля являются частью ключа индекса
2. **Сортировка**: Данные сортируются сначала по user_id, затем по status
3. **Использование**: Эффективен для - 
    - Запросов с условиями на user_id
    - Запросов с условиями на user_id И status
    - Сортировок по этим полям

_Индекс с INCLUDE (user_id) INCLUDE (status)_
1. Структура: Только user_idв ключе индекса, status хранится в листьях индекса
2. Сортировка: Данные сортируются только по user_id
3. Использование: Эффективен для:
     - Запросов с условиями только на user_id
     - Запросов, где нужны оба поля (покрывающий индекс)
     - Не поддерживает поиск/сортировку по status отдельно

_Ключевые различия_
1. Размер: INCLUDE-индекс обычно компактнее
2. Гибкость: Составной индекс поддерживает больше типов запросов
3. Производительность: Для запросов с фильтрацией по обоим полям составной индекс работает лучше
4. Поддержка: INCLUDE синтаксис доступен не во всех СУБД (появился в PostgreSQL 11, SQL Server и др.)

```sql
CREATE INDEX idx_users_name ON users(name);
```

**Hash**

- Только для точного сравнения =.
- Не поддерживает диапазоны, сортировку, LIKE.
- Редко используется, но может быть быстрее B-tree на =.

```sql
CREATE INDEX idx_users_email_hash ON users USING hash(email);
```

**GIN (Generalized Inverted Index)**

- Для массивов, jsonb, full-text search.
- Отличен при поиске по вложенным структурам или множеству значений.
- Сильно просаживает по скорости запись в БД
- Основное применение поиск по Json полям

```sql
CREATE INDEX idx_data_tags ON posts USING gin(tags);
```

**GiST (Generalized Search Tree)**

- Для геоданных (PostGIS), поиска по диапазонам, tsvector.
- Более универсален, но медленнее в некоторых кейсах, чем GIN.
- В Postgresql имеются расширения
  • pg_trgm – like, ilike, ~, ~* (regexp)
  • btree_gist – сложные constraints с интервалами

```sql
CREATE INDEX idx_events_location ON events USING gist(location);
```

**BRIN (Block Range Index)**

- Для огромных таблиц, где данные физически упорядочены.
- Занимает очень мало места.
- Не всегда эффективен — зависит от корреляции данных.

```sql
CREATE INDEX idx_logs_timestamp ON logs USING brin(timestamp);
```

**SS-таблицы и LSM-деревья**

SS-таблица (SSTable) — это файл, где ключи отсортированы и каждый встречается только один раз. Такая структура облегчает слияние сегментов даже больших файлов, не загружая всю таблицу в память, и работает по принципу сортировки слиянием.

Чтобы найти нужный ключ, не обязательно держать все индексы в памяти: достаточно знать соседние ключи и просматривать файл между ними до нужного значения.

![img.png](img/sum_01.png)

#### Алгоритм вешанья индексов
Пример от одного гуру
1. Определить цель индексирования: нужно понять, для каких операций или запросов индекс будет использоваться. Например, это может быть поиск по определенному полю, сортировка или слияние данных.

2. Оценить затраты и выгоды: провести анализ текущей структуры базы данных и определить, какие данные и операции будут выигрывать от индексирования. Оценить затраты на создание и поддержку индекса.

3. Анализ запросов: изучить типичные запросы, которые будут выполняться в базе данных, и выяснить, какие поля или комбинации полей чаще всего используются в условиях WHERE или ORDER BY. Это поможет определить, какие поля следует индексировать.

4. Избегать избыточности: создание индексов для каждого поля не всегда является эффективным решением. Определить комбинации полей, которые часто используются в запросах, и создать составные индексы для них.

5. Определить порядок сортировки: для поля, по которому будет выполняться сортировка или группировка, определить порядок и создать индекс соответствующего типа.

6. Определить уникальность: если поле должно содержать только уникальные значения, создать уникальный индекс для этого поля.

7. Обновление и поддержка индекса: учесть, что каждая операция добавления, обновления или удаления данных влияет на индексирование. Обновление индексов может занимать время и ресурсы, поэтому важно оптимизировать этот процесс.

8. Мониторинг и оптимизация: регулярно производить мониторинг производительности базы данных и запросов. Если производительность снижается, можно рассмотреть возможность создания или изменения индексов для улучшения выполнения запросов.

#### Типичные проблемы с типами данных

- **TIMESTAMP (WITHOUT TIME ZONE)** - используется по default. Нет смысла использовать TIMESTAMP (WITHOUT TIME ZONE), так как это может привести к ошибкам при вычислениях из-за отсутствия контекста часового пояса и перехода на летнее/зимнее время. Правильный тип для хранения временных меток как конкретных моментов времени — TIMESTAMP WITH TIME ZONE.
- **TIME WITH TIME ZONE** - включён в PostgreSQL только ради соответствия SQL-стандарту. Поскольку он также занимает 8 байт, нет никакой причины его использовать — вместо него рекомендуется использовать TIMESTAMPTZ.
- **CURRENT_TIME** - Если вы решите использовать CURRENT_TIME, вы столкнётесь с теми же проблемами, что и при работе с TIMETZ. Выбор нужно опираться на


| Функция                 | Тип возвращаемого значения | Пример результата |
| ------------------------------ | -------------------------------------------------- | --------------------------------- |
| CURRENT_TIMESTAMP или now() | timestamp with time zone                           | 2023-11-20 21:03:34.349275+00     |
| CURRENT_DATE                   | date                                               | 2023-11-20                        |
| CURRENT_TIME                   | time with time zone                                | 21:03:34.349275+00                |
| LOCALTIMESTAMP                 | timestamp without time zone                        | 2023-11-20 21:03:34.349275        |
| LOCALTIME                      | time without time zone                             | 21:03:34.349275                   |

- **CHAR(n)** - Это текстовый тип фиксированной длины с заполнением пробелами. Его длина всегда равна n, как указано в определении. Если строка короче n символов, оставшееся пространство дополняется пробелами. Но будьте осторожны: при использовании LIKE и регулярных выражений (regex) пробелы не игнорируются! Что ещё хуже — внутри PostgreSQL тип CHAR(n) не хранится как поле фиксированной длины. Поскольку символы могут занимать более одного байта (в зависимости от кодировки), сохраненная строка на диске представлена в виде значения переменной длины. В результате вы можете тратить место на диске впустую, сохраняя ненужные пробелы, так как они сохраняются явно. Наконец, индексы, созданные по колонкам с типом CHAR(n), могут не работать в запросах, где используется значение типа TEXT, переданное из клиента PostgreSQL.
- **VARCHAR(n)** При попытке вставить более длинную строку произойдёт ошибка: ERROR:  value too long for type character varying(5). Итог: не используйте VARCHAR(n), он может только создать проблемы, не давая при этом никаких преимуществ. Используйте TEXT.
- **Тип BPCHAR** - Игнорирует при сравнение пробелы в конце строки.
- **MONEY** - не хранит информацию о валюте и страдает от ограниченной и ошибочной реализации. Его следует избегать и вместо него использовать NUMERIC или другие числовые типы, способные точно хранить значения. При необходимости валюту лучше сохранять в отдельной колонке.
- **Тип данных SERIAL  и BIGSERIAL** - фактически устарели и были вытеснены identity-колонками, которые обладают более предсказуемым поведением в плане владения последовательностями, их использования и понятности, к какой таблице они относятся.
- **XML** — крайне неудачный выбор для хранения документов, если только вы не собираетесь просто копировать неизменяемые XML-данные в базу. Если вы планируете выполнять запросы или модифицировать данные, используйте JSON(B).

#### Fillfactor

**Fillfactor** — это параметр, который говорит PostgreSQL: оставь немного места на каждой странице, пожалуйста, заранее. То есть если ты ставишь fillfactor = 80, то Postgres будет заполнять каждую страницу на 80%, оставляя 20% под будущие апдейты. По дефолту fillfactor = 100. А значит, если часто происходят UPDATE или HOT UPDATE, можно влететь в проблему — Postgres не сможет обновить строку “на месте” и вынужден будет делать tuple forwarding (и создавать новый tuple), что ведёт к фрагментации и росту таблицы.

```sql
CREATE TABLE users (
  id serial PRIMARY KEY,
  name text,
  email text
) WITH (fillfactor = 80);

ALTER TABLE users SET (fillfactor = 70);

CREATE INDEX idx_email ON users(email) WITH (fillfactor = 90);
```

**Когда стоит занижать fillfactor вручную**

*Не трогай fillfactor, если не уверен в профиле нагрузки. По дефолту он справедлив — 100%.*

- Частые UPDATE’ы фиксированных строк
- Типичный кейс — статус заказа. Меняется несколько байт, но меняется часто.
- **Frequent UPSERT паттерны** Особенно если UPSERT делают UPDATE чаще, чем INSERT.
- **Суровые OLTP-нагрузки** Где каждый микросервис по 100 раз в секунду пишет в те же записи (а ты ещё решил shard'ить вручную, да?).
- **Частые UPDATE по jsonb / text** Где строка может даже слегка вырасти.

#### Стратегии управления транзакциями

В контексте баз данных, "ACID" и "BASE" - это два различных подхода к управлению транзакциями, определяющие, как данные обрабатываются и какие гарантии надежности и согласованности предоставляются. ACID (Atomicity, Consistency, Isolation, Durability) - это классический подход, обеспечивающий строгую согласованность данных, в то время как BASE (Basically Available, Soft state, Eventually consistent) - более гибкий подход, нацеленный на высокую доступность и отказоустойчивость, жертвуя некоторой степенью согласованности

#### ACID

Это традиционный подход, часто используемый в реляционных базах данных, таких как PostgreSQL. Он обеспечивает надежность и предсказуемость работы, но может быть более медленным и менее масштабируемым, особенно в распределенных системах.

**ACID** - Atomicity, Consistency, Isolation, Durability

- **Atomicity(Атомарность)** Гарантирует, что транзакция либо выполняется полностью, либо не выполняется вообще. Никакие частичные изменения не сохраняются.
- **Consistency(Согласованность)** Обеспечивает, что любая транзакция переводит базу данных из одного согласованного состояния в другое, то есть не нарушает предустановленные правила и ограничения.
- **Isolation(Изолированность)** Обеспечивает, что параллельно выполняющиеся транзакции не влияют друг на друга, создавая иллюзию последовательного выполнения.
- **Durability(Долговечность)** Гарантирует, что после подтверждения транзакции изменения сохраняются и не будут потеряны даже в случае сбоя системы.

#### BASE

Это подход, ориентированный на доступность и масштабируемость, часто используемый в NoSQL базах данных. Он позволяет достичь высокой производительности и отказоустойчивости за счет упрощения требований к согласованности данных, что делает его подходящим для распределенных систем, где требуется высокая доступность.

**BASE** - Basically Available, Soft state, Eventually consistent

- **Basically Available(Базовая доступность)** Гарантирует, что база данных будет доступна в любом случае.
- **Soft state(Мягкий состав)** Позволяет хранить несогласованные изменения, но не гарантирует их надежности.
- **Eventually consistent(Возможно согласованная)** Гарантирует, что данные будут согласованы в конечном состоянии, но не гарантирует их надежности.

**MySQL vs MongoDB**

![img.png](img/main00.png)

**Быстрая справка по масштабированию баз данных**

![img.png](img/sum_00.png)
1. **Индексация:** Проверьте шаблоны запросов вашего приложения и создайте подходящие индексы.
2. **Материализованные представления:** Предварительно вычислите результаты сложных запросов и сохраните их для более быстрого доступа.
3. **Денормализация:** Уменьшите количество сложных объединений для повышения производительности запросов.
4. **Вертикальное масштабирование:** Увеличьте мощность вашего сервер базы данных, добавляя больше процессоров, оперативной памяти или хранилища
5. **Кэширование:** Сохраните часто запрашиваемые данные в более быстром слое хранения для снижения нагрузки на базу данных.
6. **Репликация:** Создайте реплики основной базы данных на разных серверах для масштабирования чтения.
7. **Шардинг:** Разделите таблицы базы данных на более мелкие части и распределите их по серверам. Используется для масштабирования как записи, так и чтения.


**Репликация**
- Зачем: для отказоустойчивости и высокой доступности.
- Виды: синхронная (данные пишутся одновременно на все реплики) и асинхронная (реплики обновляются с задержкой).
- Реплика может использоваться для чтения, но запись идёт в мастер-базу.

**Шардирование**
- Каждая шард содержит часть данных (например, по диапазону ключей или хешу).
- Позволяет масштабировать систему: нагрузка на запись и чтение распределяется между несколькими инстансами.

**Секционирование**
- Например, по дате: январь, февраль, март.
- Упрощает поиск и может ускорять некоторые запросы, но все данные остаются в одной БД, в отличие от шардирования.

#### Оптимизация запросов: Индексы vs. Анализ плана выполнения 

Сейчас я покажу вам, почему простое добавление индексов не всегда ускоряет запросы. Часто встречаю ситуацию, когда разработчики по умолчанию добавляют индексы на каждое поле WHERE, но запросы всё равно работают медленно. Давайте разберёмся!  
**Миф: индексы всегда ускоряют запросы**
На самом деле, индекс может даже замедлить выполнение, если:  
- Запрос возвращает слишком много строк - сканирование индекса будет дороже, чем полное сканирование таблицы.  
- Индекс не покрывает весь запрос - приходится делать обращения к основной таблице.  
- Слишком много индексов - это замедляет INSERT/UPDATE/DELETE.  

**Как правильно анализировать?**  

Используйте EXPLAIN ANALYZE (PostgreSQL) или EXPLAIN FORMAT=JSON (MySQL) для понимания:  
- Используется ли индекс?  
-  Сколько строк проходит сканирование?  
-  Есть ли операции сортировки, которые можно избежать с индексом?  

**Что делать, если запрос медленный?**  

1. Проверить план выполнения (не добавлять индекс вслепую!).  
2. Подумать о составных индексах, если запрос фильтрует по нескольким полям.  
3. Проверить, можно ли избежать сортировки (ORDER BY по индексу).  
4. Рассмотреть материализованные представления для сложных агрегатов.  

**Оптимизация SQL-запросов: 5 ключевых техник**
1. **Используйте индексы** Индексы – это ускоритель запросов. Если у вас часто выполняются WHERE, JOIN или ORDER BY по определенному столбцу – создайте для него индекс. Но не переборщите: индексы ускоряют чтение, но замедляют вставку и обновление данных.  
2. **Избегайте SELECT** Выбирайте только нужные столбцы. SELECT * может загружать ненужные данные и нагружать сервер. Лучше указывать конкретные столбцы.  
3. **Нормализация или денормализация?** Иногда стоит разбивать таблицы (нормализация) для устранения дублирования данных. В других случаях – наоборот, объединять (денормализация) ради быстродействия. Анализируйте ситуацию!  
4. **Кеширование запросов** Если запрос выполняется часто и данные редко меняются, используйте QUERY CACHE или внешние кеширующие механизмы (Redis, Memcached).  
5. **Анализируйте планы выполнения** Команда EXPLAIN в MySQL/PostgreSQL покажет, как СУБД выполняет запрос. Это поможет найти узкие места: медленные JOIN'ы, сканы всей таблицы и т.д.
6. **Избегать использование OR** Выполнение операций раздельно с использованием индексов выгодней чем полное сканирование таблицы.

#### Работа с датами

- **Используйте правильный тип данных**  
   Не храните даты в VARCHAR! Всегда используйте DATE, DATETIME или TIMESTAMP. Это не только экономит место, но и ускоряет запросы.  
- **Не используйте NOW() в WHERE без обработки**  
   Запрос вида:  
   ```sql
    SELECT * FROM orders WHERE order_date > NOW() - INTERVAL 7 DAY;
   ```
  может привести к тому, что индексы не будут использоваться. Лучше заранее вычислить диапазон и передать его в запрос.
- **Сравнение по диапазону – ключ к оптимизации**  
   Для фильтрации по дате лучше использовать BETWEEN:  
   ```sql
    SELECT * FROM orders WHERE order_date BETWEEN '2024-02-01' AND '2024-02-07';
   ```
- **Осторожно с часовыми поясами**  
   Если ваш сервис работает глобально, храните время в UTC и конвертируйте на уровне приложения.  
- **Агрегируйте правильно**  
  Часто нужно сгруппировать данные по дням или месяцам:  
   ```sql
    SELECT DATE(order_date) AS order_day, COUNT(*) FROM orders GROUP BY order_day;
   ```
  Но если поле order_date – DATETIME, такие операции могут игнорировать индексы. Лучше использовать GROUP BY DATE_FORMAT(order_date, '%Y-%m-%d') или завести отдельное DATE-поле.

#### В чем разница между SQL и NoSQL базой
SQL бд:
- Сложные запросы и JOIN — когда нужны агрегации и связи между таблицами
- Транзакции ACID — банковские операции, финансовые системы
- Структурированные данные — четкая схема, предсказуемая структура
- Целостность данных — внешние ключи, constraints
- Отчетность и аналитика — сложные SQL-запросы

Подходят для: банковские системы (транзакции), медицинские записи (целостность данных), интернет-магазины (заказы, inventory)

NoSQL бд:
- Большие объемы данных — Big Data, логгирование
- Горизонтальное масштабирование — распределенные системы
- Гибкая схема — часто меняющаяся структура данных
- Высокая производительность записи — IoT, сенсоры, clickstream
- Неструктурированные данные — JSON, документы, графы

Подходят для: проекты, где работают с документами, где нужно обрабатывать огромные объемы данных(например я знаю, что в VK Video используют cassandra в качестве БД), структура данных часто меняется

**ACID vs. BASE в NoSQL-базах данных**
Свойства BASE можно описать следующим образом:
1. Basically available (базовая доступность). Система гарантирует ответ на запрос, даже если часть узлов недоступна или вышла из строя.
2. Soft state (мягкое состояние). Из-за асинхронных обновлений состояние системы может меняться со временем, даже без прямого пользовательского ввода.
3. Eventual consistency (согласованность в конечном итоге). Данные со временем придут к согласованному состоянию, но на коротких промежутках возможны расхождения.
Различия между этими принципами можно выделить в три пункта.
1. ACID обеспечивает строгую согласованность после каждой транзакции, строго соблюдая правила целостности. BASE жертвует строгой согласованностью ради производительности и доступности — данные могут быть временно несогласованными, но придут в порядок позже.
2. ACID-системы ставят во главу угла согласованность, из-за чего могут становиться недоступными при сбоях. BASE-системы ориентированы на высокую доступность и остаются отзывчивыми даже при сетевых проблемах или отказах отдельных узлов.
3. ACID-системам сложно масштабироваться горизонтально, поскольку строгая согласованность на распределённых системах требует значительных ресурсов. BASE-системы легко масштабируются и рассчитаны на распределённую архитектуру, где допустимы временные несогласованности.

#### Когда можно использовать денормализацию БД

Денормализация — это сознательное объединение данных, которые обычно хранятся в разных таблицах, чтобы уменьшить количество соединений (JOIN) и ускорить запросы. Используют, когда:
- Часто выполняются сложные запросы с большим количеством JOIN, и это становится узким местом по производительности.
- Нужна оптимизация чтения в системах с высокой нагрузкой на SELECT.
- Можно пожертвовать скоростью записи ради ускорения чтения (так как обновление денормализованных данных сложнее).

#### VIEW
- Это виртуальная таблица, которая хранит только запрос, а не данные. 
- Данные берутся из базовых таблиц каждый раз при обращении.
- Плюс: удобство, безопасность, можно скрыть сложные JOIN’ы.
- Минус: запросы могут быть медленнее, если базовые таблицы большие.

#### Materialized VIEW 
- Это настоящая таблица, которая хранит результат запроса.
- Нельзя вставлять, обновлять или удалять строки напрямую — изменения происходят только через REFRESH MATERIALIZED VIEW.
- Плюс: быстрый доступ к данным, не нужно пересчитывать результат при каждом запросе.
- Минус: нужно периодически обновлять, чтобы данные оставались актуальными
