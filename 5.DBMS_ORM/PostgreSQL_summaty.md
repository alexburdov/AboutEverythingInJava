### PostgreSQL краткие заметки

#### Миграции
**Правила безопасных миграций:**
- **Идемпотентность**
  ```sql
  CREATE TABLE IF NOT EXISTS users ( ... ); -- Хорошо
  CREATE TABLE users ( ... ); -- Плохо (упадет при повторном запуске)
  ```
- **DDL в транзакциях** В PostgreSQL DDL можно обернуть в транзакцию
  ```sql
  BEGIN;
  ALTER TABLE orders ADD COLUMN status TEXT;
  -- CONCURRENTLY нельзя в транзакции!
  CREATE INDEX CONCURRENTLY idx_orders_user_id ON orders(user_id);
  COMMIT;
  ```
- **Долгие операции — только с CONCURRENTLY** Создание/удаление индексов на больших таблицах:
  ```sql
    -- Не блокирует запись
  CREATE INDEX CONCURRENTLY idx_orders_created_at ON orders(created_at);
  ```
- **Изменение колонок через новую колонку** Прямой ALTER TYPE блокирует таблицу! Рецепт:
  1. Добавить новую колонку new_column с нужным типом
  2. Добавить триггер на UPDATE для сохранения значений и в старое, и в новое поле.
  3. Перенести констрейнты и индексы
  4. Написать фоновый скрипт для копирования исторических данных.
  5. Переименовать старую колонку, переименовать новую
  6. Если все ОК, то удалить старую колонку и индексы.

- Релизы и откаты
    - Всегда пишите down-миграции.
    - Для данных используйте обратимые преобразования: 
  ```sql
  -- up
  UPDATE users SET status = 'active' WHERE status = 'new';
  
  -- down
  UPDATE users SET status = 'new' WHERE status = 'active';
  ```
  
#### Практики оптимизации
- EXPLAIN — ваш лучший друг
  ```sql
    EXPLAIN (ANALYZE, BUFFERS) 
    SELECT * FROM orders WHERE user_id = 123 AND status = 'shipped';
  ```
- Индексы: не просто добавить, а правильно выбрать
  - Составные индексы: (user_id, order_id) вместо двух отдельных
  - Частичные индексы для фильтрации:
  ```sql
      CREATE INDEX idx_orders_active ON orders(user_id) 
      WHERE status = 'active'; -- Индекс в 10-100 раз меньше!
  ```
  - Используйте покрывающие индексы (Index-Only Scan):
  ```sql
      CREATE INDEX idx_orders_covering ON orders (created_at, user_id)
      INCLUDE (total);
      -- Запрос использует только индекс:
      SELECT user_id, total FROM orders WHERE created_at > '2023-01-01';
  ```

  - Бойтесь N+1 в ORM
  ```
  # Плохо: 100+ запросов для 100 пользователей
   users = User.objects.all()
   for user in users:
    print(user.orders.count())

  # Хорошо
    users = User.objects.prefetch_related('orders').all()
  ```
  
#### Соглашение по именованию
**Правила именования:**
- **Таблицы**: snake_case (users, order_items). Часто предпочтение отдается именованию в единственном числе.
- **Колонки**: created_at, user_id (не UserId или creationDate)
- **Первичные ключи**: id (не user_id в таблице users)
- **Внешние ключи**: user_id (не userId или owner)
- **Индексы**: idx_table_column (idx_orders_user_id)
- **Ограничения**: pk_table (pk_users), fk_table_reference (fk_orders_users)
  
**Избегайте:**
- Зарезервированных слов
- Префиксов (tbl_users) — это не SQL Server 2000

#### Где чаще всего ошибаются

1. **Транзакции на все запросы BEGIN/COMMIT** ORM делает неявные транзакции? Проверьте настройки! Явный контроль — надежнее.
2. **SELECT * в коде приложения** Тащите только нужные поля:
    ```sql
   SELECT id, email FROM users; -- Вместо SELECT *
   ```
3. **Игнорирование блокировок** Долгая транзакция = блокировка записей. Используйте:
  ```sql
  SET lock_timeout = '5s'; -- Прервать запрос при долгом ожидании
  ```
4. **Миграции без тестирования** Всегда тестируйте миграции UP и DOWN. Если в одном релизе несколько миграций, то тестируйте возможность отката к исходному состоянию после каждой миграции и учитывайте необходимость совместимости кода с схемой БД после каждой миграции, чтобы правильно выбрать порядок миграций и деплоя новой версии кода.
5. **Касетные обновления/удаления** Всегда добавляйте LIMIT в цикле:
  ```sql
    WHILE EXISTS (SELECT 1 FROM orders WHERE status = 'old') 
    LOOP
        DELETE FROM orders WHERE status = 'old' LIMIT 1000;
        COMMIT; -- Освобождаем блокировки
    END LOOP;
  ```
6. **Миграция содержит операции,** которые блокируют таблицу с большим количеством данных и нагрузкой. Например, изменение типа столбца, добавление столбца с дефолтным значением, добавление индекса. По возможности нужно использовать CONCURRENTLY и делать это не в миграциях, а на прод-БД. Например, в случае с Django миграция выполняется с флагом --fake, а сами изменения делаются вручную с CONCURRENTLY, если это возможно. Главное — не блокировать таблицу надолго, иначе наше приложение не будет работать, пока не завершится блокирующая операция. Всегда до релиза убедитесь, что вы не делаете блокирующих операций на больших таблицах.
7. **Старая версия кода не работает** после применения миграций. Допустим, после применения миграции приложение не сможет работать на старой версии кода. В этом случае необходимо сначала выполнить деплой новой версии, где приложение будет иметь возможность работать до и после миграции, поддерживая и старую, и новую схему БД. Например, если мы удаляем столбец, то нам нужно сначала выполнить деплой новой версии кода, в которой не используется этот столбец, и только потом применять миграцию, которая удаляет столбец. Если мы добавляем столбец, то необходимо сначала выполнить миграцию, а потом деплой новой версии кода. Могут быть разные ситуации в том числе, когда мы выполняем миграции и до, и после деплоя. Основной посыл здесь в том, что мы всегда должны думать о совместимости кода с схемой БД, особенно когда у нас несколько ДЦ.
8. **Медленные запросы.** Часто разработчики забывают, что если все работает быстро у них локально или на тестовом сервере, это не означает, что так же будет и на проде, где сотни миллионов записей в таблицах. Если добавили SQL-запрос или внесли изменения в существующий, проверяйте план запроса с помощью EXPLAIN и убедитесь, что в запросе используются эффективные индексы. Если есть сомнения, обратитесь за ревью к опытным коллегам или сгенерируйте побольше данных в локальной БД для проверки индексов.

#### Чеклист перед запуском в прод
1. Миграция идемпотентна и имеет down-скрипт.
2. Индексы для новых запросов протестированы через EXPLAIN на большом объёме данных. На небольшом объёме индексы могут не использоваться или планировщик может выбрать другой индекс.
3. ORM-запросы не генерируют N+1.
4. Имена сущностей соответствуют конвенции команды.
5. Длительные операции разбиты на батчи.
6. Миграция не блокирует таблицы длительно. Если есть долгая операция, то она выполняется не в миграции, а вручную на prod-БД и использует CONCURRENTLY, если возможно. Например, хорошей практикой является не допускать блокировок (более тяжелых, чем AccessExclusiveLock) длительностью более 1–5 секунд на высоконагруженных таблицах. На практике обычно предпочитают вообще не выполнять в миграциях операции дольше 3–5 секунд, даже если они не блокирующие.
7. Миграции должны быть обратно совместимы — применённая миграция не должна влиять на работу текущей версии приложения. Расширять до, изменять во время, очищать после.
8. Миграция схемы БД и миграция данных разделены (рекомендации DSF).
9. Откат миграции планируется и проверяется также, как и её применение.
10. Разработчик обязан убедиться, что после каждого шага миграции приложение будет работать корректно.
11. Все изменения SQL-запросов протестированы на предмет наличия необходимых эффективных индексов.

#### Обнаружение проблем производительности 
- pg_stat_statements (Хорошее решение для общих случаев)
- pgBadger (пользоваться с осторожностью - искаженная картина - так как логирование не полное или просадка производительности)

**Представление pg_stats**
Статистика собирается по 30k записей. Есть способы изменять размеры этого окна, а так же какие таблицы оно задействует.
Необходимые поля этого представления:
  - Уникальность значений: n_distinct
  - Упорядоченность значений: correlation
  - Объемы null: null_frac
  - Частые значения: most_common_vals и most_common_freqs

#### Покрывающий индекс
Это индекс, который содержит все нужные поля прямо в себе. PostgreSQL с версии 11 умеет делать это через INCLUDE.
```sql

-- Запрос
SELECT name, email FROM users WHERE status = 'active';

-- Обычный индекс
CREATE INDEX idx_users_status ON users(status);

-- Покрывающий индекс
CREATE INDEX idx_users_status_cover ON users(status) INCLUDE (name, email);
```
Теперь PostgreSQL может ответить на запрос только по индексу, не трогая таблицу → быстрее.

#### Соединения (Connections)

PostgreSQL по умолчанию позволяет одновременно до 100 соединений (max_connections).
- **Проблема**: слишком много прямых соединений создают нагрузку на память и CPU.
- **Решение**: используйте пуллинг через PgBouncer или Pgpool-II.
- **Совет**: на проде стремитесь держать max_connections < 200 и масштабируйте через пуллер.
```ini
  [databases]
  mydb = host=127.0.0.1 port=5432 dbname=mydb

  [pgbouncer]
  listen_addr = 0.0.0.0
  listen_port = 6432
  pool_mode = transaction
  max_client_conn = 500
  default_pool_size = 20
```
#### Буфер (Shared Buffers & Work Mem)

PostgreSQL активно использует память для кэширования страниц и сортировок.

- **shared_buffers**  – основной буфер кэша:
```
  shared_buffers = 4GB        # ≈25% от RAM на выделенном сервере
```

- **work_mem**  – память на сортировку/слияние одного потока:
```
  work_mem = 64MB             # для сложных запросов с сортировками и хэш-джоинами
  maintenance_work_mem = 512MB # для VACUUM/CREATE INDEX
```

**Best practice:**
- Установите shared_buffers ≈ 25% RAM.
- Настройте work_mem исходя из числа параллельных операций, не превышайте общий объём памяти

#### WAL (Write-Ahead Log)
WAL обеспечивает надёжность и репликацию.
- **wal_level**  – детальность логирования:
```
  wal_level = replica       # для потоковой репликации
```
- **checkpoint_timeout** и **max_wal_size**:
```
  checkpoint_timeout = 10min
  max_wal_size = 1GB
```
 
- **Архивация WAL** для резервных копий:
```
  archive_mode = on
  archive_command = 'cp %p /mnt/backup/wal/%f'
```
 
**Рекомендации:**
- Увеличьте max_wal_size, если у вас большие всплески нагрузки.
- Настройте сжатие WAL (pg_wal) для экономии места.

