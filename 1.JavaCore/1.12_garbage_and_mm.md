### 1.12 Сборщики мусора и модели памяти

#### 1.12.1 Сборщик мусора

#### Serial Garbage Collector

Лучший вариант для однопоточных приложений с небольшими кучами. Он использует один поток для выполнения как малых, так и больших сборок мусора, что приводит к значительным паузам, но минимальной нагрузке на систему.

#### Parallel Garbage Collector

Подходит для приложений с высокими требованиями к пропускной способности. Использует несколько потоков для выполнения как малых, так и больших сборок мусора, уменьшая время пауз, но при этом увеличивая использование CPU.

#### Concurrent Mark-Sweep (CMS) Garbage Collector

Разработан для минимизации пауз за счёт выполнения основной части работы по сборке мусора параллельно с выполнением приложений. Подходит для приложений, где критически важна низкая задержка.

#### G1 Garbage Collector

Сбалансированный сборщик мусора, который стремится обеспечить предсказуемое время пауз, разделяя кучу на регионы и выполняя сборку мусора поэтапно. Является хорошим выбором по умолчанию для большинства приложений.

#### Z Garbage Collector и Shenandoah

Сборщики мусора с ультранизкой задержкой, разработанные для работы с большими кучами. Основная часть работы по сборке мусора выполняется параллельно, что позволяет минимизировать время пауз даже при очень больших кучах.

#### 1.12.2 Модель памяти

![img.png](img/mm01.png)

![img.png](img/mm02.png)

#### Стек (Stack)

Стек используется для хранения локальных переменных, параметров методов и возвращаемых значений, а также для управления вызовами методов.

#### Куча (Heap)

Куча используется для хранения объектов, созданных во время выполнения программы.

![img.png](img/mm03.png)

**Eden**

Это сегмент heap области в который свежесозданные объекты попадают в первую очередь. Каждый раз, когда в Java приложении выполняется инструкция new, память, выделяемая под новый инстанс, выделяется именно в Eden сегменте.

Для этого правила есть исключения - если размер памяти, необходимый для хранения инстанса достаточно большой, то JVM может выделить память под него сразу в Old Gen сегменте.

Надолго свежесозданные объекты в Eden сегменте не задержатся. После первого же запуска процесса сборки мусора, они либо будут удалены из памяти, либо будут перенесены в Survival сегменты heap'а.

**S0 и S1 - Survival**

Survival сегмент области heap'а используется JVM для хранения объектов, которые пережили один и более проходов сборщика мусора.

Survival сегмент представлен в JVM двумя сегментами - S0 и S1. Они служат неким "перевалочным пунктом" для объектов на пути к Old Gen сегменту. В S0 и S1 сегментах объекты могут провести какое-то время до тех пор, пока они не будут удалены из памяти или переведены в Old Gen сегмент.

Если быть точным, то в JVM есть настройка, позволяющая указать количество запусков сборки мусора, которое объект должен пережить, для того, чтобы попасть в Old Gen сегмент. По умолчанию, это количество равно 15.

Почему Survival область представлена двумя сегментами S0 и S1? Всё дело в том, что для ускорения очистки памяти и исправления её фрагментации, в ходе процесса сборки мусора два этих сегмента дефрагминтируются и меняются местами.

**Old Gen**

Old Gen сегмент heap'а используется для хранения объектов, которые пережили установленное количество запусков сборки мусора.

Полная схема памяти Java процесса выглядит следующим образом:

![img.png](img/mm04.png)

**Управление Heap**

Управлять heap областью можно с помощью следующих флагов JVM:

- -Xms - минимальный объём памяти всей области
- -Xmx - максимальный объём памяти всей области
- -XX:NewSize - минимальный объём памяти Eden сегмента
- -XX:MaxNewSize - максималный объём памяти Eden сегмента
- -XX:SurvivorRatio - соотношение между объёмами памяти Eden и Survival сегментов

#### Metaspace

Metaspace - это область памяти в которой хранится статическая инфорация Java приложения, такая как метаданные загруженных классов. По умолчанию, metaspace увеличивается автоматически и не имеет явного ограничения. Без установленного ограничения размер metaspace неявно ограничен объёмом системной памяти хоста.

Управлять metaspace областью можно с помощью следующих флагов JVM:

- -XX:MetaspaceSize - минимальный объём памяти для области
- -XX:MaxMetaspaceSize - максимальный объём памяти для области
- -XX:MinMetaspaceFreeRatio - минимально зарезервированный размер памяти после очистки GC (в процентах)
- -XX:MaxMetaspaceFreeRatio - максимально зарезервированный размер памяти после очистки GC (в процентах)

**============ Не основные ============**

#### Область методов

Область методов хранит метаданные классов, такие как константный пул, код методов и другую информацию, необходимую для работы с классами.

#### Область нативных методов

Область нативных методов используется для хранения данных, необходимых для выполнения нативных (не Java) методов

#### PC Register

Каждый поток в JVM имеет свой собственный PC Register. Он используется для отслеживания текущей позиции выполнения потока в программе

#### Типы ссылок

**Сильная ссылка**

Это самые популярные ссылочные типы, к которым мы все привыкли. В приведенном выше примере со StringBuilder мы фактически храним сильную ссылку на объект из кучи. Объект в куче не удаляется сборщиком мусора, пока на него указывает сильная ссылка или если он явно доступен через цепочку сильных ссылок.

**Слабая ссылка**

Попросту говоря, слабая ссылка на объект из кучи, скорее всего, не сохранится после следующего процесса сборки мусора. Слабая ссылка создается следующим образом:

```java
    import java.lang.ref.WeakReferencestringbuilder reference = new WeakReference<>(new StringBuilder());
```

Хорошим вариантом использования слабых ссылок являются сценарии кеширования. Представьте, что вы извлекаете некоторые данные и хотите, чтобы они также были сохранены в памяти - те же данные могут быть запрошены снова. С другой стороны, вы не уверены, когда и будут ли эти данные запрашиваться снова. Таким образом, вы можете сохранить слабую ссылку на него, и в случае запуска сборщика мусора, возможно, он уничтожит ваш объект в куче. Следовательно, через некоторое время, если вы захотите получить объект, на который вы ссылаетесь, вы можете внезапно получить null значение. Хорошей реализацией сценариев кеширования является коллекция WeakHashMap <K, V>. Если мы откроем WeakHashMap класс в Java API, мы увидим, что его записи фактически расширяют WeakReferenceкласс и используют его поле ref в качестве ключа отображения (Map):

```java
    /**
    * The entries in this hash table extend WeakReference, using its main ref
    * field as the key.
    */

    private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {

        V value;
```

После сбора мусора ключа из WeakHashMap вся запись удаляется из карты.

**Мягкая ссылка**

Эти типы ссылок используются для более чувствительных к памяти сценариев, поскольку они будут собираться сборщиком мусора только тогда, когда вашему приложению не хватает памяти. Следовательно, пока нет критической необходимости в освобождении некоторого места, сборщик мусора не будет касаться легко доступных объектов. Java гарантирует, что все объекты, на которые имеются мягкие ссылки, будут очищены до того, как будет выдано исключение OutOfMemoryError. В документации Javadocs говорится, что «все мягкие ссылки на мягко достижимые объекты гарантированно очищены до того, как виртуальная машина выдаст OutOfMemoryError».
Подобно слабым ссылкам, мягкая ссылка создается следующим образом:

```java
SoftReference<StringBuilder> reference = new SoftReference<>(new StringBuilder());
```

**Фантомная ссылка**

Используется для планирования посмертных действий по очистке, поскольку мы точно знаем, что объекты больше не живы. Используется только с очередью ссылок, поскольку .get()метод таких ссылок всегда будет возвращаться null. Эти типы ссылок считаются предпочтительными для финализаторов.
