### 1.10 Многопоточность

#### Техники проектирования потокобезопасного класса

1. Классы без состояния: нет состояния — нет проблемы
2. Неизменяемые классы: только для чтения — ваш друг
3. Инкапсуляция и синхронизация
    - Сделайте поля приватными
    - Выявите неатомарные операции и синхронизируйте их
    - Ключевое слово volatile для видимости
    - Широкая и узкая синхронизация 
        
        Широкая синхронизация означает использование меньшего количества более широких блокировок, которые защищают большие участки кода или структуры данных. Например, блокировка всего списка, когда нужно изменить только один элемент, или блокировка всего метода, даже если только часть метода нуждается в синхронизации.
        
        Узкая синхронизация означает использование множества мелких, целенаправленных блокировок, которые защищают конкретные компоненты или операции. Например, блокировка только того элемента списка, который вы изменяете.

4. Использование потокобезопасных библиотек 
5. Изоляция потока: каждый со своим набором данных
6. Оборонительное копирование: защита внутренних данных

 **Классы без состояния устраняют общее состояние полностью.**
 
 **Неизменяемые классы защищены от любых изменений после создания.**
 
 **Правильная инкапсуляция с синхронизацией защищает изменяемое состояние.**
 
 **Готовые библиотеки — отличный фундамент для создания сложных потокобезопасных решений.**
 
 **Ограничение потока изолирует состояние в отдельных потоках.**
 
 **Оборонительное копирование защищает от внешних изменений.**
 
 **Выбор, где и как лочить, — это всегда компромисс между стабильностью и скоростью.** ![multithread](img/multithread.png)

#### Atomic
В Java atomic относится к классу java.util.concurrent.atomic, предоставляющему атомарные операции для работы с примитивными типами данных и объектами. Атомарные операции гарантируют, что операции чтения и записи выполняются как неделимое целое, не прерываемое другими потоками. Это полезно для обеспечения потокобезопасности в многопоточных приложениях, особенно при работе с общими переменными. 

Условно можно разделить подходы реализации большинства atomic-методов на две группы: compare-and-set и set-and-get.

Методы категории compare-and-set принимают старое значение и новое. Если переданное старое значение совпало с текущим, устанавливается новое. Обычно делегируют вызов в методы класса Unsafe, которые заменяются нативными реализациями виртуальной машины. Виртуальная машина в большинстве случаев использует атомарную операцию процессора compare-and-swap (CAS). Поэтому атомики обычно более эффективны чем стандартная дорогостоящая блокировка.

В случае set-and-get старое значение неизвестно. Поэтому нужен небольшой трюк: программа сначала считывает текущее значение, а затем записывает новое, тоже с помощью CAS, потому что запись могла успеть поменяться даже за этот шаг. Эта попытка чтения+записи повторяется в цикле, пока старое значение не совпадет и переменная не будет успешно записана.


