### Dependency Injection: анти-паттерны

#### «Control Freak». Руководитель-наркоман.
Все зависимости контролируются напрямую. Противоположность принципу инверсии управления.
Антипаттерн возникает всегда, когда мы внутри класса явно создаем изменяемую зависимость, используя ключевое слово new. Класс, который не отпускает контроль над своими зависимостями, является Control Freak. 

**Признаки**
 *Непосредственное создание экземпляров зависимых классов.*
 *Отказ от использования абстракций в пользу конкретных типов.*

**Основная проблема**
    *Увеличение числа неявных зависимостей объекта.*

**Способы решения**
 *Использовать интерфейсы и абстракции, а не конкретные реализации.*
 *Применить внедрение зависимостей вместо порождения экземпляров классов. Наиболее часто здесь применимы внедрение зависимостей через конструктор и свойства.*
 *При разрешении зависимостей для создания экземпляров можно использовать фабричный метод или абстрактную фабрику, возвращающие интерфейсы, а не конкретные типы.*

#### «Bastard Injection». Внебрачная зависимость.
Данный пункт подразумевает множественные перегрузки конструкторов вместе с «конструкторами по умолчанию», которые повсеместно встречаются в .Net, включая BCL. Основная проблема в том, что внешние зависимости обычно определены в других модулях и подобные конструкторы увеличивают связность системы буквально на пустом месте. Следует избегать внебрачных внешних зависимостей везде где возможно, а разрешение зависимостей отдать DI-контейнеру. 

**Признаки**
 *Наличие конструктора по умолчанию, который вызывает параметризированный.*

**Основная проблемы**
 *Увеличение числа неявных зависимостей объекта.*
 
**Способы решения**
 *Убрать конструктор по умолчанию, который и несет зависимости от конкретных типов.*
 *Использовать:*
 *внедрение через конструктор если зависимость внешняя (например другого слоя);*
 *или через свойства, если зависимость от внутренних объектов.*

#### «Constrained Construction». Ограниченное построение.
Анти-паттерн возникает, если существует требование ко всем зависимостям иметь «особенный» конструктор. Данное требование зачастую проистекает из желания «однотипно создавать через Reflection».

**Признаки**
 *Наличие жестких требований к конструкторам объектов, реализующим интерфейсы.*
 *Чтобы понять, является ли ограничение на список параметров антишаблоном Constrained Construction, необходимо проанализировать насколько они связаны с конкретной реализаций объекта (как правило, вариант по умолчанию).*

**Основная проблема**
    *Привязка абстракции к конкретной реализации и, как следствие, потеря гибкости.*

**Способы решения**
 *Создания механизма, который способен создавать объекты с любым типом конструктора. Подобные механизмы есть практически во всех библиотеках, реализующих поддержку внедрения зависимостей.*
 *Использование шаблона Абстрактная фабрика для создания связанных групп объектов.*
 
#### «Service Locator». Сервис-локатор.
Анти-паттерн возникает при гранулированном получении отдельных сервисов в различных частях кода.
Автор перечисленных DI-анти-паттернов признает, что вопрос сервис-локатора дискуссионный, однако продолжает считать Service Locator анти-паттерном, аргументируя в основном тем, что бизнес-логика не должна знать об инфраструктурных вещах, одной из которых является сервис-локатор и все зависимости должны пробрасываться явно. 

**Признаки**
 *Отсутствие явных зависимостей у объектов.*
 *Наличие внутри кода методов запросов для получения реализаций тех или иных интерфейсов.*
 
**Основная проблема**
*Service Locator почти работает. Именно почти. Он решает все задачи, связанные с внедрением зависимостей. Главная и единственная его проблема – они все неявные. Глядя на сигнатуры конструкторов и методов класса нельзя определить использует ли он какие-либо зависимости или нет.*

*Это приводит к проблеме повторного использования объектов, которые полагаются на Service Locator. Ведь даже если в данный момент они работают, то нет никакой гарантии что в дальнейшем они не затребует какой-либо не реализованный интерфейс. Помочь могут только или подробная документация или подробное изучение исходного кода.*

**Способы решения**
 *Отказ от использования Service Locator и переход к внедрению зависимостей через конструктор, свойство или параметр метода.*

#### Single Responsibility Principle (SRP) Violation
Это даже не антишаблон, а проявление нарушения принципа единственной ответственности. Его можно встретить при переходе к использованию внедрения зависимостей.

**Признаки**
 *Конструктор объекта требует большое число внешних зависимостей.*

**Основная проблема**
 *Объект и интерфейс, который он реализует, скорее всего отвечает за несколько различных задач.*

**Способы решения**
 *Пересмотр обязанностей интерфейса и объекта, разделение его на несколько небольших, реализующих различные интерфейсы.*
 *Использование разных способов внедрения зависимостей:*
 *через свойство – для внутренних зависимостей;*
 *через параметр метода – если зависимость нужна только в одном методе.*